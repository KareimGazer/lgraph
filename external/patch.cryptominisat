diff --git include/cryptominisat5/cryptominisat.h include/cryptominisat5/cryptominisat.h
new file mode 100644
index 00000000..ef1b0b28
--- /dev/null
+++ include/cryptominisat5/cryptominisat.h
@@ -0,0 +1,172 @@
+/******************************************
+Copyright (c) 2016, Mate Soos
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+***********************************************/
+
+#ifndef __CRYPTOMINISAT5_H__
+#define __CRYPTOMINISAT5_H__
+
+#define CRYPTOMINISAT_VERSION_MAJOR 5
+#define CRYPTOMINISAT_VERSION_MINOR 6
+#define CRYPTOMINISAT_VERSION_PATCH 5
+
+#include <atomic>
+#include <vector>
+#include <iostream>
+#include <utility>
+#include <string>
+#include "cryptominisat5/solvertypesmini.h"
+
+namespace CMSat {
+    struct CMSatPrivateData;
+    #ifdef _WIN32
+    class __declspec(dllexport) SATSolver
+    #else
+    class SATSolver
+    #endif
+    {
+    public:
+        SATSolver(void* config = NULL
+        , std::atomic<bool>* interrupt_asap = NULL
+        );
+        ~SATSolver();
+
+        ////////////////////////////
+        // Adding variables and clauses
+        ////////////////////////////
+
+        void new_var(); //add a new variable to the solver
+        void new_vars(const size_t n); //and many new variables to the solver -- much faster
+        unsigned nVars() const; //get number of variables inside the solver
+        bool add_clause(const std::vector<Lit>& lits);
+        bool add_xor_clause(const std::vector<unsigned>& vars, bool rhs);
+
+        ////////////////////////////
+        // Solving and simplifying
+        ////////////////////////////
+
+        lbool solve(const std::vector<Lit>* assumptions = 0, bool only_indep_solution = false); //solve the problem, optionally with assumptions. If only_indep_solution is set, only the independent variables set with set_independent_vars() are returned in the solution
+        lbool simplify(const std::vector<Lit>* assumptions = 0); //simplify the problem, optionally with assumptions
+        const std::vector<lbool>& get_model() const; //get model that satisfies the problem. Only makes sense if previous solve()/simplify() call was l_True
+        const std::vector<Lit>& get_conflict() const; //get conflict in terms of the assumptions given in case the previous call to solve() was l_False
+        bool okay() const; //the problem is still solveable, i.e. the empty clause hasn't been derived
+
+        ////////////////////////////
+        // Debug all calls for later replay with --debuglit FILENAME
+        ////////////////////////////
+        void log_to_file(std::string filename);
+
+        ////////////////////////////
+        // SQLite for statistics gathering
+        ////////////////////////////
+        void set_sqlite(std::string filename);
+        void add_sql_tag(const std::string& tagname, const std::string& tag);
+        unsigned long get_sql_id() const;
+
+        ////////////////////////////
+        // Configuration
+        // -- Note that nothing else can be changed, only these.
+        // -- The main.cpp has access to the internal config, but it changes
+        // -- all the time and hence exposing it to the outside world would
+        // -- be very brittle.
+        ////////////////////////////
+
+        void set_num_threads(unsigned n); //Number of threads to use. Must be set before any vars/clauses are added
+        void set_allow_otf_gauss(); //allow on-the-fly gaussian elimination
+        void set_max_time(double max_time); //max time to run to on next solve() call
+        void set_max_confl(int64_t max_confl); //max conflict to run to on next solve() call
+        void set_verbosity(unsigned verbosity = 0); //default is 0, silent
+        void set_default_polarity(bool polarity); //default polarity when branching for all vars
+        void set_no_simplify(); //never simplify
+        void set_no_simplify_at_startup(); //doesn't simplify at start, faster startup time
+        void set_no_equivalent_lit_replacement(); //don't replace equivalent literals
+        void set_no_bva(); //No bounded variable addition
+        void set_no_bve(); //No bounded variable elimination
+        void set_greedy_undef(); //Try to set variables to l_Undef in solution
+        void set_independent_vars(std::vector<uint32_t>* ind_vars);
+        void set_timeout_all_calls(double secs); //max timeout on all subsequent solve() or simplify
+
+
+        ////////////////////////////
+        // Get generic info
+        ////////////////////////////
+        static const char* get_version(); //get solver version in string format
+        static const char* get_version_sha1(); //get SHA1 version string of the solver
+        static const char* get_compilation_env(); //get compilation environment string
+        std::string get_text_version_info();  //get printable version and copyright text
+
+
+        ////////////////////////////
+        // Get info about only the last solve() OR simplify() call
+        // summed for all threads
+        ////////////////////////////
+        uint64_t get_last_conflicts(); //get total number of conflicts of last solve() or simplify() call of all threads
+        uint64_t get_last_propagations();  //get total number of propagations of last solve() or simplify() call made by all threads
+        uint64_t get_last_decisions(); //get total number of decisions of last solve() or simplify() call made by all threads
+
+
+        ////////////////////////////
+        //Get info about total sum of all time of all threads
+        ////////////////////////////
+
+        uint64_t get_sum_conflicts(); //get total number of conflicts of all time of all threads
+        uint64_t get_sum_propagations();  //get total number of propagations of all time made by all threads
+        uint64_t get_sum_decisions(); //get total number of decisions of all time made by all threads
+
+        void print_stats() const; //print solving stats. Call after solve()/simplify()
+        void set_drat(std::ostream* os, bool set_ID); //set drat to ostream, e.g. stdout or a file
+        void interrupt_asap(); //call this asynchronously, and the solver will try to cleanly abort asap
+        void dump_irred_clauses(std::ostream *out) const; //dump irredundant clauses to this stream when solving finishes
+        void dump_red_clauses(std::ostream *out) const; //dump redundant ("learnt") clauses to this stream when solving finishes
+        void open_file_and_dump_irred_clauses(std::string fname) const; //dump irredundant clauses to this file when solving finishes
+        void open_file_and_dump_red_clauses(std::string fname) const; //dump redundant ("learnt") clauses to this file when solving finishes
+        void add_in_partial_solving_stats(); //used only by Ctrl+C handler. Ignore.
+
+        ////////////////////////////
+        // Extract useful information from the solver
+        // This can be used in the theory solver
+
+        ////////////////////////////
+        std::vector<Lit> get_zero_assigned_lits() const; //get literals of fixed value
+        std::vector<std::pair<Lit, Lit> > get_all_binary_xors() const; //get all binary XORs that are = 0
+
+        //////////////////////
+        // EXPERIMENTAL
+        std::vector<std::pair<std::vector<uint32_t>, bool> > get_recovered_xors(bool elongate) const; //get XORs recovered. If "elongate" is TRUE, then variables shared ONLY by two XORs will be XORed together
+
+        //////////////////////
+        //Below must be done in-order. Multi-threading not allowed.
+        // EXPERIMENTAL!!!
+
+        void start_getting_small_clauses(uint32_t max_len, uint32_t max_glue);
+        bool get_next_small_clause(std::vector<Lit>& ret); //returns FALSE if no more
+        void end_getting_small_clauses();
+
+    private:
+
+        ////////////////////////////
+        // Do not bother with this, it's private
+        ////////////////////////////
+
+        CMSatPrivateData *data;
+    };
+}
+
+#endif //__CRYPTOMINISAT5_H__
diff --git include/cryptominisat5/cryptominisat_c.h include/cryptominisat5/cryptominisat_c.h
new file mode 100644
index 00000000..51922e78
--- /dev/null
+++ include/cryptominisat5/cryptominisat_c.h
@@ -0,0 +1,75 @@
+/******************************************
+Copyright (c) 2016, @Storyyeller
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+***********************************************/
+
+#pragma once
+#include <stddef.h>
+#include <stdint.h>
+
+typedef struct c_Lit { uint32_t x; } c_Lit;
+typedef struct c_lbool { uint8_t x; } c_lbool;
+typedef struct slice_Lit { const c_Lit* vals; size_t num_vals; } slice_Lit;
+typedef struct slice_lbool { const c_lbool* vals; size_t num_vals; } slice_lbool;
+
+#ifdef __cplusplus
+    #define NOEXCEPT noexcept
+
+    namespace CMSat{ struct SATSolver; }
+    using CMSat::SATSolver;
+
+    extern "C" {
+#else
+    // c stuff
+    #include <stdbool.h>
+    #define NOEXCEPT
+
+    #define L_TRUE (0u)
+    #define L_FALSE (1u)
+    #define L_UNDEF (2u)
+
+    // forward declaration
+    typedef struct SATSolver SATSolver;
+#endif
+
+#if defined _WIN32
+    #define CMS_DLL_PUBLIC __declspec(dllexport)
+#else
+    #define CMS_DLL_PUBLIC __attribute__ ((visibility ("default")))
+#endif
+
+CMS_DLL_PUBLIC SATSolver* cmsat_new(void) NOEXCEPT;
+CMS_DLL_PUBLIC void cmsat_free(SATSolver* s) NOEXCEPT;
+
+CMS_DLL_PUBLIC unsigned cmsat_nvars(const SATSolver* self) NOEXCEPT;
+CMS_DLL_PUBLIC bool cmsat_add_clause(SATSolver* self, const c_Lit* lits, size_t num_lits) NOEXCEPT;
+CMS_DLL_PUBLIC bool cmsat_add_xor_clause(SATSolver* self, const unsigned* vars, size_t num_vars, bool rhs) NOEXCEPT;
+CMS_DLL_PUBLIC void cmsat_new_vars(SATSolver* self, const size_t n) NOEXCEPT;
+
+CMS_DLL_PUBLIC c_lbool cmsat_solve(SATSolver* self) NOEXCEPT;
+CMS_DLL_PUBLIC c_lbool cmsat_solve_with_assumptions(SATSolver* self, const c_Lit* assumptions, size_t num_assumptions) NOEXCEPT;
+CMS_DLL_PUBLIC slice_lbool cmsat_get_model(const SATSolver* self) NOEXCEPT;
+CMS_DLL_PUBLIC slice_Lit cmsat_get_conflict(const SATSolver* self) NOEXCEPT;
+
+CMS_DLL_PUBLIC void cmsat_set_num_threads(SATSolver* self, unsigned n) NOEXCEPT;
+
+#ifdef __cplusplus
+} // end extern c
+#endif
diff --git include/cryptominisat5/dimacsparser.h include/cryptominisat5/dimacsparser.h
new file mode 100644
index 00000000..ebdf5eda
--- /dev/null
+++ include/cryptominisat5/dimacsparser.h
@@ -0,0 +1,529 @@
+/*****************************************************************************
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+CryptoMiniSat -- Copyright (c) 2009 Mate Soos
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+******************************************************************************/
+
+#ifndef DIMACSPARSER_H
+#define DIMACSPARSER_H
+
+#include <string.h>
+#include "streambuffer.h"
+#include "cryptominisat5/cryptominisat.h"
+#include <cstdlib>
+#include <cmath>
+
+using namespace CMSat;
+using std::vector;
+
+template <class C>
+class DimacsParser
+{
+    public:
+        DimacsParser(SATSolver* solver, const std::string* debugLib, unsigned _verbosity);
+
+        template <class T> bool parse_DIMACS(T input_stream, const bool strict_header);
+        uint64_t max_var = std::numeric_limits<uint64_t>::max();
+        vector<uint32_t> independent_vars;
+        const std::string dimacs_spec = "http://www.satcompetition.org/2009/format-benchmarks2009.html";
+        const std::string please_read_dimacs = "\nPlease read DIMACS specification at http://www.satcompetition.org/2009/format-benchmarks2009.html";
+
+    private:
+        bool parse_DIMACS_main(C& in);
+        bool readClause(C& in);
+        bool parse_and_add_clause(C& in);
+        bool parse_and_add_xor_clause(C& in);
+        bool match(C& in, const char* str);
+        bool printHeader(C& in);
+        bool parseComments(C& in, const std::string& str);
+        std::string stringify(uint32_t x) const;
+        bool parse_solve_simp_comment(C& in, const bool solve);
+        void write_solution_to_debuglib_file(const lbool ret) const;
+        bool parseIndependentSet(C& in);
+        std::string get_debuglib_fname() const;
+
+
+        SATSolver* solver;
+        std::string debugLib;
+        unsigned verbosity;
+
+        //Stat
+        size_t lineNum;
+
+        //Printing partial solutions to debugLibPart1..N.output when "debugLib" is set to TRUE
+        uint32_t debugLibPart = 1;
+
+        //check header strictly
+        bool strict_header = false;
+        bool header_found = false;
+        int num_header_vars = 0;
+        int num_header_cls = 0;
+
+        //Reduce temp overhead
+        vector<Lit> lits;
+        vector<uint32_t> vars;
+
+        size_t norm_clauses_added = 0;
+        size_t xor_clauses_added = 0;
+};
+
+#include <sstream>
+#include <iostream>
+#include <iomanip>
+#include <vector>
+#include <fstream>
+#include <complex>
+#include <cassert>
+
+using std::vector;
+using std::cout;
+using std::endl;
+
+template<class C>
+DimacsParser<C>::DimacsParser(
+    SATSolver* _solver
+    , const std::string* _debugLib
+    , unsigned _verbosity
+):
+    solver(_solver)
+    , verbosity(_verbosity)
+    , lineNum(0)
+{
+    if (_debugLib) {
+        debugLib = *_debugLib;
+    }
+}
+
+template<class C>
+std::string DimacsParser<C>::stringify(uint32_t x) const
+{
+    std::ostringstream o;
+    o << x;
+    return o.str();
+}
+
+template<class C>
+bool DimacsParser<C>::readClause(C& in)
+{
+    int32_t parsed_lit;
+    uint32_t var;
+    for (;;) {
+        if (!in.parseInt(parsed_lit, lineNum)) {
+            return false;
+        }
+        if (parsed_lit == 0) {
+            break;
+        }
+
+        var = std::abs(parsed_lit)-1;
+
+        if (var > max_var) {
+            std::cerr
+            << "ERROR! "
+            << "Variable requested is too large for DIMACS parser parameter: "
+            << var << endl
+            << "--> At line " << lineNum+1
+            << please_read_dimacs
+            << endl;
+            return false;
+        }
+
+        if (var >= (1ULL<<28)) {
+            std::cerr
+            << "ERROR! "
+            << "Variable requested is far too large: " << var + 1 << endl
+            << "--> At line " << lineNum+1
+            << please_read_dimacs
+            << endl;
+            return false;
+        }
+
+        if (strict_header && !header_found) {
+            std::cerr
+            << "ERROR! "
+            << "DIMACS header ('p cnf vars cls') never found!" << endl;
+            return false;
+        }
+
+        if ((int)var >= num_header_vars && strict_header) {
+            std::cerr
+            << "ERROR! "
+            << "Variable requested is larger than the header told us." << endl
+            << " -> var is : " << var + 1 << endl
+            << " -> header told us maximum will be : " << num_header_vars << endl
+            << " -> At line " << lineNum+1
+            << endl;
+            return false;
+        }
+
+        if (var >= solver->nVars()) {
+            assert(!strict_header);
+            solver->new_vars(var - solver->nVars() +1);
+        }
+
+        lits.push_back( (parsed_lit > 0) ? Lit(var, false) : Lit(var, true) );
+        if (*in != ' ') {
+            std::cerr
+            << "ERROR! "
+            << "After last element on the line must be 0" << endl
+            << "--> At line " << lineNum+1
+            << please_read_dimacs
+            << endl
+            << endl;
+            return false;
+        }
+    }
+
+    return true;
+}
+
+template<class C>
+bool DimacsParser<C>::match(C& in, const char* str)
+{
+    for (; *str != 0; ++str, ++in)
+        if (*str != *in)
+            return false;
+    return true;
+}
+
+template<class C>
+bool DimacsParser<C>::printHeader(C& in)
+{
+    if (match(in, "p cnf")) {
+        if (header_found && strict_header) {
+            std::cerr << "ERROR: CNF header ('p cnf vars cls') found twice in file! Exiting." << endl;
+            exit(-1);
+        }
+        header_found = true;
+
+        if (!in.parseInt(num_header_vars, lineNum)
+            || !in.parseInt(num_header_cls, lineNum)
+        ) {
+            return false;
+        }
+        if (verbosity) {
+            cout << "c -- header says num vars:   " << std::setw(12) << num_header_vars << endl;
+            cout << "c -- header says num clauses:" <<  std::setw(12) << num_header_cls << endl;
+        }
+        if (num_header_vars < 0) {
+            std::cerr << "ERROR: Number of variables in header cannot be less than 0" << endl;
+            return false;
+        }
+        if (num_header_cls < 0) {
+            std::cerr << "ERROR: Number of clauses in header cannot be less than 0" << endl;
+            return false;
+        }
+
+        if (solver->nVars() < (size_t)num_header_vars) {
+            solver->new_vars(num_header_vars-solver->nVars());
+        }
+    } else {
+        std::cerr
+        << "PARSE ERROR! Unexpected char (hex: " << std::hex
+        << std::setw(2)
+        << std::setfill('0')
+        << "0x" << *in
+        << std::setfill(' ')
+        << std::dec
+        << ")"
+        << " At line " << lineNum+1
+        << "' in the header, at line " << lineNum+1
+        << please_read_dimacs
+        << endl;
+        return false;
+    }
+
+    return true;
+}
+
+template<class C>
+std::string DimacsParser<C>::get_debuglib_fname() const
+{
+    std::string sol_fname = debugLib + "-debugLibPart" + stringify(debugLibPart) +".output";
+    return sol_fname;
+}
+
+template<class C>
+bool DimacsParser<C>::parse_solve_simp_comment(C& in, const bool solve)
+{
+    vector<Lit> assumps;
+    in.skipWhitespace();
+    while(*in != ')') {
+        int lit;
+        if (!in.parseInt(lit, lineNum)) {
+            return false;
+        }
+        assumps.push_back(Lit(std::abs(lit)-1, lit < 0));
+        in.skipWhitespace();
+    }
+
+    if (verbosity) {
+        cout
+        << "c -----------> Solver::"
+        << (solve ? "solve" : "simplify")
+        <<" called (number: "
+        << std::setw(3) << debugLibPart << ") with assumps :";
+        for(Lit lit: assumps) {
+            cout << lit << " ";
+        }
+        cout << "<-----------" << endl;
+    }
+
+    lbool ret;
+    if (solve) {
+        if (verbosity) {
+            cout << "c Solution will be written to: "
+            << get_debuglib_fname() << endl;
+        }
+        ret = solver->solve(&assumps);
+        write_solution_to_debuglib_file(ret);
+        debugLibPart++;
+    } else {
+        ret = solver->simplify(&assumps);
+    }
+
+    if (verbosity >= 6) {
+        cout << "c Parsed Solver::"
+        << (solve ? "solve" : "simplify")
+        << endl;
+    }
+    return true;
+}
+
+template<class C>
+void DimacsParser<C>::write_solution_to_debuglib_file(const lbool ret) const
+{
+    //Open file for writing
+    std::string s = get_debuglib_fname();
+    std::ofstream partFile;
+    partFile.open(s.c_str());
+    if (!partFile) {
+        std::cerr << "ERROR: Cannot open part file '" << s << "'";
+        std::exit(-1);
+    }
+
+    //Output to part file the result
+    if (ret == l_True) {
+        partFile << "s SATISFIABLE\n";
+        partFile << "v ";
+        for (uint32_t i = 0; i != solver->nVars(); i++) {
+            if (solver->get_model()[i] != l_Undef)
+                partFile
+                << ((solver->get_model()[i]==l_True) ? "" : "-")
+                << (i+1) <<  " ";
+        }
+        partFile << "0\n";
+    } else if (ret == l_False) {
+        partFile << "conflict ";
+        for (Lit lit: solver->get_conflict()) {
+            partFile << lit << " ";
+        }
+        partFile
+        << "\ns UNSAT\n";
+    } else if (ret == l_Undef) {
+        cout << "c timeout, exiting" << endl;
+        std::exit(15);
+    } else {
+        assert(false);
+    }
+    partFile.close();
+}
+
+template<class C>
+bool DimacsParser<C>::parseComments(C& in, const std::string& str)
+{
+    if (!debugLib.empty() && str.substr(0, 13) == "Solver::solve") {
+        if (!parse_solve_simp_comment(in, true)) {
+            return false;
+        }
+    } else if (!debugLib.empty() && str.substr(0, 16) == "Solver::simplify") {
+        if (!parse_solve_simp_comment(in, false)) {
+            return false;
+        }
+    } else if (!debugLib.empty() && str == "Solver::new_var()") {
+        solver->new_var();
+
+        if (verbosity >= 6) {
+            cout << "c Parsed Solver::new_var()" << endl;
+        }
+    } else if (!debugLib.empty() && str == "Solver::new_vars(") {
+        in.skipWhitespace();
+        int n;
+        if (!in.parseInt(n, lineNum)) {
+            return false;
+        }
+        solver->new_vars(n);
+
+        if (verbosity >= 6) {
+            cout << "c Parsed Solver::new_vars( " << n << " )" << endl;
+        }
+    } else if (str == "ind") {
+        if (!parseIndependentSet(in)) {
+            return false;
+        }
+    } else {
+        if (verbosity >= 6) {
+            cout
+            << "didn't understand in CNF file comment line:"
+            << "'c " << str << "'"
+            << endl;
+        }
+    }
+    in.skipLine();
+    lineNum++;
+    return true;
+}
+
+template<class C>
+bool DimacsParser<C>::parse_and_add_clause(C& in)
+{
+    lits.clear();
+    if (!readClause(in)) {
+        return false;
+    }
+    in.skipWhitespace();
+    if (!in.skipEOL(lineNum)) {
+        return false;
+    }
+    lineNum++;
+    solver->add_clause(lits);
+    norm_clauses_added++;
+    return true;
+}
+
+template<class C>
+bool DimacsParser<C>::parse_and_add_xor_clause(C& in)
+{
+    lits.clear();
+    if (!readClause(in)) {
+        return false;
+    }
+    if (!in.skipEOL(lineNum)) {
+        return false;
+    }
+    lineNum++;
+    if (lits.empty())
+        return true;
+
+    bool rhs = true;
+    vars.clear();
+    for(Lit& lit: lits) {
+        vars.push_back(lit.var());
+        if (lit.sign()) {
+            rhs ^= true;
+        }
+    }
+    solver->add_xor_clause(vars, rhs);
+    xor_clauses_added++;
+    return true;
+}
+
+template<class C>
+bool DimacsParser<C>::parse_DIMACS_main(C& in)
+{
+    std::string str;
+
+    for (;;) {
+        in.skipWhitespace();
+        switch (*in) {
+        case EOF:
+            return true;
+        case 'p':
+            if (!printHeader(in)) {
+                return false;
+            }
+            in.skipLine();
+            lineNum++;
+            break;
+        case 'c':
+            ++in;
+            in.parseString(str);
+            if (!parseComments(in, str)) {
+                return false;
+            }
+            break;
+        case 'x':
+            ++in;
+            if (!parse_and_add_xor_clause(in)) {
+                return false;
+            }
+            break;
+        case '\n':
+            std::cerr
+            << "c WARNING: Empty line at line number " << lineNum+1
+            << " -- this is not part of the DIMACS specifications ("
+            << dimacs_spec << "). Ignoring."
+            << endl;
+            in.skipLine();
+            lineNum++;
+            break;
+        default:
+            if (!parse_and_add_clause(in)) {
+                return false;
+            }
+            break;
+        }
+    }
+
+    return true;
+}
+
+template <class C>
+template <class T>
+bool DimacsParser<C>::parse_DIMACS(T input_stream, const bool _strict_header)
+{
+    debugLibPart = 1;
+    strict_header = _strict_header;
+    const uint32_t origNumVars = solver->nVars();
+
+    C in(input_stream);
+    if ( !parse_DIMACS_main(in)) {
+        return false;
+    }
+
+    if (verbosity) {
+        cout
+        << "c -- clauses added: " << norm_clauses_added << endl
+        << "c -- xor clauses added: " << xor_clauses_added << endl
+        << "c -- vars added " << (solver->nVars() - origNumVars)
+        << endl;
+    }
+
+    return true;
+}
+
+template <class C>
+bool DimacsParser<C>::parseIndependentSet(C& in)
+{
+    int32_t parsed_lit;
+    for (;;) {
+        if (!in.parseInt(parsed_lit, lineNum)) {
+            return false;
+        }
+        if (parsed_lit == 0) {
+            break;
+        }
+        uint32_t var = std::abs(parsed_lit) - 1;
+        independent_vars.push_back(var);
+    }
+    return true;
+}
+
+#endif //DIMACSPARSER_H
diff --git include/cryptominisat5/solvertypesmini.h include/cryptominisat5/solvertypesmini.h
new file mode 100644
index 00000000..571cb351
--- /dev/null
+++ include/cryptominisat5/solvertypesmini.h
@@ -0,0 +1,215 @@
+/******************************************
+Copyright (c) 2016, Mate Soos
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+***********************************************/
+
+#ifndef __SOLVERTYPESMINI_H__
+#define __SOLVERTYPESMINI_H__
+
+#include <cstdint>
+#include <iostream>
+#include <cassert>
+#include <vector>
+
+namespace CMSat {
+
+#define var_Undef (0xffffffffU >> 4)
+
+class TooManyVarsError {};
+class TooLongClauseError {};
+
+class Lit
+{
+    uint32_t x;
+    explicit Lit(uint32_t i) : x(i) { }
+public:
+    Lit() : x(var_Undef<<1) {}   // (lit_Undef)
+    explicit Lit(uint32_t var, bool is_inverted) :
+        x(var + var + is_inverted)
+    {}
+
+    const uint32_t& toInt() const { // Guarantees small, positive integers suitable for array indexing.
+        return x;
+    }
+    Lit  operator~() const {
+        return Lit(x ^ 1);
+    }
+    Lit  operator^(const bool b) const {
+        return Lit(x ^ (uint32_t)b);
+    }
+    Lit& operator^=(const bool b) {
+        x ^= (uint32_t)b;
+        return *this;
+    }
+    bool sign() const {
+        return x & 1;
+    }
+    uint32_t  var() const {
+        return x >> 1;
+    }
+    Lit  unsign() const {
+        return Lit(x & ~1U);
+    }
+    bool operator==(const Lit& p) const {
+        return x == p.x;
+    }
+    bool operator!= (const Lit& p) const {
+        return x != p.x;
+    }
+    /**
+    @brief ONLY to be used for ordering such as: a, b, ~b, etc.
+    */
+    bool operator <  (const Lit& p) const {
+        return x < p.x;     // '<' guarantees that p, ~p are adjacent in the ordering.
+    }
+    bool operator >  (const Lit& p) const {
+        return x > p.x;
+    }
+    bool operator >=  (const Lit& p) const {
+        return x >= p.x;
+    }
+    static Lit toLit(uint32_t data)
+    {
+        return Lit(data);
+    }
+};
+
+static const Lit lit_Undef(var_Undef, false);  // Useful special constants.
+static const Lit lit_Error(var_Undef, true );  //
+
+inline std::ostream& operator<<(std::ostream& os, const Lit lit)
+{
+    if (lit == lit_Undef) {
+        os << "lit_Undef";
+    } else {
+        os << (lit.sign() ? "-" : "") << (lit.var() + 1);
+    }
+    return os;
+}
+
+inline std::ostream& operator<<(std::ostream& co, const std::vector<Lit>& lits)
+{
+    for (uint32_t i = 0; i < lits.size(); i++) {
+        co << lits[i];
+
+        if (i != lits.size()-1)
+            co << " ";
+    }
+
+    return co;
+}
+
+#define l_True  lbool((uint8_t)0) // gcc does not do constant propagation if these are real constants.
+#define l_False lbool((uint8_t)1)
+#define l_Undef lbool((uint8_t)2)
+
+
+class llbool;
+
+class lbool {
+    uint8_t value;
+
+public:
+    explicit lbool(uint8_t v) : value(v) { }
+
+    lbool()       : value(0) { }
+    explicit lbool(bool x) : value(!x) { }
+    inline lbool(llbool b);
+
+    bool  operator == (lbool b) const {
+        return ((b.value & 2) & (value & 2)) | (!(b.value & 2) & (value == b.value));
+    }
+    bool  operator != (lbool b) const {
+        return !(*this == b);
+    }
+    lbool operator ^  (bool  b) const {
+        return lbool((uint8_t)(value ^ (uint8_t)b));
+    }
+
+    lbool operator && (lbool b) const {
+        uint8_t sel = (this->value << 1) | (b.value << 3);
+        uint8_t v   = (0xF7F755F4 >> sel) & 3;
+        return lbool(v);
+    }
+
+    lbool operator || (lbool b) const {
+        uint8_t sel = (this->value << 1) | (b.value << 3);
+        uint8_t v   = (0xFCFCF400 >> sel) & 3;
+        return lbool(v);
+    }
+
+    uint8_t getValue() const { return value; }
+
+    friend int   toInt  (lbool l);
+    friend lbool toLbool(int   v);
+    friend class llbool;
+};
+
+inline lbool boolToLBool(const bool b)
+{
+    if (b)
+        return l_True;
+    else
+        return l_False;
+}
+
+
+/**
+@brief A very hackish lbool that also supports l_Nothing and l_Continue
+*/
+class llbool
+{
+    char value;
+
+public:
+    llbool(): value(0) {}
+    llbool(lbool v) :
+            value(v.value) {}
+    llbool(char a) :
+            value(a) {}
+
+    inline bool operator!=(const llbool& v) const {
+        return (v.value != value);
+    }
+
+    inline bool operator==(const llbool& v) const {
+        return (v.value == value);
+    }
+
+    friend class lbool;
+};
+static const llbool l_Nothing  = llbool(2);
+static const llbool l_Continue = llbool(3);
+inline lbool::lbool(llbool b): value(b.value) {
+    assert(b != l_Nothing);
+    assert(b != l_Continue);
+}
+
+inline std::ostream& operator<<(std::ostream& cout, const lbool val)
+{
+    if (val == l_True) cout << "l_True";
+    if (val == l_False) cout << "l_False";
+    if (val == l_Undef) cout << "l_Undef";
+    return cout;
+}
+
+}
+
+#endif //__SOLVERTYPESMINI_H__
diff --git include/cryptominisat5/streambuffer.h include/cryptominisat5/streambuffer.h
new file mode 100644
index 00000000..6b4fea34
--- /dev/null
+++ include/cryptominisat5/streambuffer.h
@@ -0,0 +1,208 @@
+/*******************************************************************************
+MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
+associated documentation files (the "Software"), to deal in the Software without restriction,
+including without limitation the rights to use, copy, modify, merge, publish, distribute,
+sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or
+substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
+NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
+DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
+OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*******************************************************************************/
+
+#ifndef STREAMBUFFER_H
+#define STREAMBUFFER_H
+
+static const unsigned chunk_limit = 148576;
+
+#include <stdio.h>
+#include <iostream>
+#include <iomanip>
+#include <limits>
+#include <string>
+#include <memory>
+
+#ifdef USE_ZLIB
+#include <zlib.h>
+struct GZ {
+    static inline int read(void* buf, size_t num, size_t count, gzFile f)
+    {
+        return gzread(f, buf, num*count);
+    }
+};
+#endif
+
+struct FN {
+    static inline int read(void* buf, size_t num, size_t count, FILE* f)
+    {
+        return fread(buf, num, count, f);
+    }
+};
+
+struct CH {
+    static inline int read(void* buf, size_t num, size_t count, const char*& f)
+    {
+        int toread = num*count;
+        char* mybuf = (char*)buf;
+
+        int read = 0;
+        while(*f != 0 && read < toread) {
+            *mybuf = *f;
+            mybuf++;
+            f++;
+            read++;
+        }
+        return read;
+    }
+};
+
+template<typename A, typename B>
+class StreamBuffer
+{
+    A  in;
+    void assureLookahead() {
+        if (pos >= size) {
+            pos  = 0;
+            size = B::read(buf.get(), 1, chunk_limit, in);
+        }
+    }
+    int     pos;
+    int     size;
+    std::unique_ptr<char[]> buf;
+
+    void advance()
+    {
+        operator++();
+    }
+    int value()
+    {
+        return operator*();
+    }
+
+public:
+    StreamBuffer(A i) :
+        in(i)
+        , pos(0)
+        , size(0)
+        , buf(new char[chunk_limit]())
+    {
+        assureLookahead();
+    }
+
+    int  operator *  () {
+        return (pos >= size) ? EOF : buf[pos];
+    }
+    void operator ++ () {
+        pos++;
+        assureLookahead();
+    }
+
+    void skipWhitespace()
+    {
+        char c = value();
+        while (c == '\t' || c == '\r' || c == ' ') {
+            advance();
+            c = value();
+        }
+    }
+
+    void skipLine()
+    {
+        for (;;) {
+            if (value() == EOF || value() == '\0') return;
+            if (value() == '\n') {
+                advance();
+                return;
+            }
+            advance();
+        }
+    }
+
+    bool skipEOL(const size_t lineNum)
+    {
+        for (;;) {
+            if (value() == EOF || value() == '\0') return true;
+            if (value() == '\n') {
+                advance();
+                return true;
+            }
+            if (value() != '\r') {
+                std::cerr
+                << "PARSE ERROR! Unexpected char (hex: " << std::hex
+                << std::setw(2)
+                << std::setfill('0')
+                << "0x" << value()
+                << std::setfill(' ')
+                << std::dec
+                << ")"
+                << " At line " << lineNum+1
+                << " we expected an end of line character (\\n or \\r + \\n)"
+                << std::endl;
+                return false;
+            }
+            advance();
+        }
+        exit(-1);
+    }
+
+    inline bool parseInt(int32_t& ret, size_t lineNum, bool allow_eol = false)
+    {
+        int32_t val = 0;
+        int32_t mult = 1;
+        skipWhitespace();
+        if (value() == '-') {
+            mult = -1;
+            advance();
+        } else if (value() == '+') {
+            advance();
+        }
+
+        char c = value();
+        if (allow_eol && c == '\n') {
+            ret = std::numeric_limits<int32_t>::max();
+            return true;
+        }
+        if (c < '0' || c > '9') {
+            std::cerr
+            << "PARSE ERROR! Unexpected char (dec: '" << c << ")"
+            << " At line " << lineNum
+            << " we expected a number"
+            << std::endl;
+            return false;
+        }
+
+        while (c >= '0' && c <= '9') {
+            int32_t val2 = val*10 + (c - '0');
+            if (val2 < val) {
+                std::cerr << "PARSE ERROR! At line " << lineNum
+                << " the variable number is to high"
+                << std::endl;
+                return false;
+            }
+            val = val2;
+            advance();
+            c = value();
+        }
+        ret = mult*val;
+        return true;
+    }
+
+    void parseString(std::string& str)
+    {
+        str.clear();
+        skipWhitespace();
+        while (value() != ' ' && value() != '\n' && value() != EOF) {
+            str.push_back(value());
+            advance();
+        }
+    }
+};
+
+#endif //STREAMBUFFER_H
diff --git src/GitSHA1.cpp src/GitSHA1.cpp
new file mode 100644
index 00000000..d28a6c8c
--- /dev/null
+++ src/GitSHA1.cpp
@@ -0,0 +1,65 @@
+/******************************************
+Copyright (c) 2017, Mate Soos
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+***********************************************/
+
+#include "src/GitSHA1.h"
+
+const char* CMSat::get_version_sha1()
+{
+    static const char myversion_sha1[] = "4c26a766aab2a452aed9a8fe6f28f4171bcb8690";
+    return myversion_sha1;
+}
+
+const char* CMSat::get_version_tag()
+{
+    static const char myversion_tag[] = "5.6.5";
+    return myversion_tag;
+}
+
+const char* CMSat::get_compilation_env()
+{
+    static const char compilation_env[] =
+    "CMAKE_CXX_COMPILER = /usr/bin/c++ | "
+    "CMAKE_CXX_FLAGS =  -mtune=native -Wall -Wextra -Wunused -Wsign-compare -fno-omit-frame-pointer -Wtype-limits -Wuninitialized -Wno-deprecated -Wstrict-aliasing -Wpointer-arith -Wpointer-arith -Wformat-nonliteral -Winit-self -Wparentheses -Wunreachable-code -ggdb3 -Wlogical-op -Wrestrict -Wnull-dereference -Wdouble-promotion -Wshadow -Wformat=2 -Wextra-semi -pedantic -Wno-class-memaccess | "
+    "COMPILE_DEFINES =  -DUSE_GAUSS | "
+    "STATICCOMPILE = ON | "
+    "ONLY_SIMPLE = OFF | "
+    "Boost_FOUND = 1 | "
+    "STATS = OFF | "
+    "SQLITE3_FOUND =  | "
+    "ZLIB_FOUND =  | "
+    "VALGRIND_FOUND = FALSE | "
+    "ENABLE_TESTING = OFF | "
+    "M4RI_FOUND =  | "
+    "NOM4RI = ON | "
+    "SLOW_DEBUG = OFF | "
+    "ENABLE_ASSERTIONS = ON | "
+    "PYTHON_EXECUTABLE = /usr/bin/python3 | "
+    "PYTHON_LIBRARY = /usr/lib/libpython3.7m.so | "
+    "PYTHON_INCLUDE_DIRS = /usr/include/python3.7m | "
+    "MY_TARGETS =  | "
+    "LARGEMEM = OFF | "
+    "LIMITMEM = OFF | "
+    "compilation date time = " __DATE__ " " __TIME__
+    ""
+    ;
+    return compilation_env;
+}
diff --git src/libcryptominisat5_export.h src/libcryptominisat5_export.h
new file mode 100644
index 00000000..db172887
--- /dev/null
+++ src/libcryptominisat5_export.h
@@ -0,0 +1,42 @@
+
+#ifndef LIBCRYPTOMINISAT5_EXPORT_H
+#define LIBCRYPTOMINISAT5_EXPORT_H
+
+#ifdef LIBCRYPTOMINISAT5_STATIC_DEFINE
+#  define LIBCRYPTOMINISAT5_EXPORT
+#  define LIBCRYPTOMINISAT5_NO_EXPORT
+#else
+#  ifndef LIBCRYPTOMINISAT5_EXPORT
+#    ifdef libcryptominisat5_EXPORTS
+        /* We are building this library */
+#      define LIBCRYPTOMINISAT5_EXPORT 
+#    else
+        /* We are using this library */
+#      define LIBCRYPTOMINISAT5_EXPORT 
+#    endif
+#  endif
+
+#  ifndef LIBCRYPTOMINISAT5_NO_EXPORT
+#    define LIBCRYPTOMINISAT5_NO_EXPORT 
+#  endif
+#endif
+
+#ifndef LIBCRYPTOMINISAT5_DEPRECATED
+#  define LIBCRYPTOMINISAT5_DEPRECATED __attribute__ ((__deprecated__))
+#endif
+
+#ifndef LIBCRYPTOMINISAT5_DEPRECATED_EXPORT
+#  define LIBCRYPTOMINISAT5_DEPRECATED_EXPORT LIBCRYPTOMINISAT5_EXPORT LIBCRYPTOMINISAT5_DEPRECATED
+#endif
+
+#ifndef LIBCRYPTOMINISAT5_DEPRECATED_NO_EXPORT
+#  define LIBCRYPTOMINISAT5_DEPRECATED_NO_EXPORT LIBCRYPTOMINISAT5_NO_EXPORT LIBCRYPTOMINISAT5_DEPRECATED
+#endif
+
+#if 0 /* DEFINE_NO_DEPRECATED */
+#  ifndef LIBCRYPTOMINISAT5_NO_DEPRECATED
+#    define LIBCRYPTOMINISAT5_NO_DEPRECATED
+#  endif
+#endif
+
+#endif /* LIBCRYPTOMINISAT5_EXPORT_H */
